# 객체 & 클래스

객체(object)와 클래스(class)의 기본 개념

## TOC

- [객체지향 프로그래밍](#객체지향-프로그래밍)
- [캡슐화](#캡슐화)
- [클래스 개념](#클래스-개념)
- [클래스 정의](#클래스-정의)
  - [필드 정의](#필드-정의)
  - [메서드 정의](#메서드-정의)
- [객체 생성과 초기화](#객체-생성과-초기화)
  - [필드의 초기값](#필드의-초기값)
  - [필드 초기화](#필드-초기화)
  - [생성자](#생성자)
  - [생성자 오버로딩](#생성자-오버로딩)
  - [this() 생성자 호출](#this-생성자-호출)
- [객체 접근](#객체-접근)
- [접근 제한자](#접근-제한자)
  - [클래스 접근 제한자](#클래스-접근-제한자)
  - [접근 제한자와 캡슐화](#접근-제한자와-캡슐화)

<br>

## 객체지향 프로그래밍

객체지향 프로그래밍(object-oriented programming, oop)은 프로그램을 객체 간 상호작용을 통해 구성하는 방법론을 말한다. 현실 세계의 개념적/물리적 대상이 가지는 상태(속성)와 행동(기능)이라는 특성을 소프트웨어적으로 모델링한 것이 객체다.

- 객체는 연관된 속성과 기능을 묶은 소프트웨어 구성요소
- 객체의 속성은 변수에 저장
- 객체의 기능은 함수를 통해 표현하고 외부에 노출
- 함수를 통해 객체 간 상호작용

<br>

## 캡슐화

캡슐화는 oop의 특징 중 하나로 관련된 속성, 기능을 하나의 캡슐로 감싸서 외부로부터 보호하는 것을 말한다.

캡슐화 장점

- 정보 보호 → 객체 외부에서의 속성 조작을 제한하여 잘못된 조작을 방지
- 정보 은닉 → 객체의 사용자에게 내부 구조를 숨기고 필요한 기능만 제공가능

캡슐화 원칙

- 객체의 속성은 외부에 절대 노출하지 않을 것
  - 속성을 안전하게 조작하는 로직을 무시할 가능성이 있는 외부 접근을 차단
  - 속성은 객체가 제공하는 메서드를 통해서만 접근하게 할 것
- 객체의 기능은 사용자 기준 필요한 것만 노출할 것
  - 객체 내부에서만 쓰는 기능은 숨김
  - 사용자가 필요한 기능만 쓰도록 해서 기능의 오남용 방지

<br>

## 클래스 개념

클래스는 객체에 대한 설계도로 객체의 속성, 기능이 정의된다. 일반적으로 클래스에 정의된 속성이나 기능등을 멤버라고 표현한다.

멤버 종류

- 멤버 변수 → 객체의 속성을 저장하기 위한 변수, 자바에서는 필드라 표현
- 멤버 함수 → 객체의 기능을 나타내는 함수, 자바에서는 메서드라 표현

> 객체 vs 인스턴스
>
> 객체(object)와 인스턴스(instance) 모두 생성되어 메모리에 존재하는 객체를 의미하며 기본적으로 혼용된다. 단 인스턴스는 특정 클래스로부터 생성된 객체임을 강조하며 "A 클래스의 인스턴스" 처럼 해당 객체가 어떤 클래스에 속하는지 보다 명확하게 할 때 주로 쓰인다.

<br>

## 클래스 정의

클래스를 정의하는 기본구조

```java
class 클래스이름 {
    // 멤버 정의...
}
```

- `class` 키워드로 클래스를 정의
- 클래스 이름은 관례상 파스칼 케이스로 작성
- `{}` 블록 내에 멤버에 대한 내용을 포함

계좌에 해당하는 `Account` 클래스 정의

```java
class Account {
    ...
}
```

### 필드 정의

객체의 속성에 해당하는 필드 정의

```java
class A {
    타입 필드이름;
}
```

- 필드는 클래스 본문 블록 내에 정의
- 필드이름은 관례상 카멜 케이스로 작성

`Account` 클래스에 계좌 잔액(정수)을 나타낼 필드 정의

```java
class Account {
    int balance;
}
```

### 메서드 정의

메서드는 객체의 기능에 해당하며 호출되면 메서드 본문 코드 블록을 순서대로 실행한다. 필요한 경우 호출자로부터 매개변수를 전달 받을 수 있고 호출자에게 값을 반환할 수 있다.

```java
class A {
    반환타입 메서드이름(매개변수 목록) {
        // 메서드 본문
        return xxx; // 반환할 값이 있는 경우 사용
    }
}
```

- 메서드는 클래스 본문 블록 내에 정의
- 메서드 이름은 관레상 카멜 케이스로 작성하며 동사로 시작
- 반환 타입은 메서드 종료 시 호출자에게 넘겨줄 값의 타입
  - `return` 문에서 반환할 값의 타입과 일치 또는 호환되어야 함
  - `void` 로 지정할 경우 반환값 자체가 없음을 의미
- 매개변수 목록은 호출자가 메서드 호출 시 넘겨줄 값의 목록

`Account` 클래스에 입금 기능에 해당하는 메서드 정의

```java
class Account {
    ...
    void deposit(int amount) {
        balance += amount;
    }
    ...
}
```

`Account` 클래스에 현재 잔액을 반환하는 메서드 정의

```java
class Account {
    int balance;
    ...
    int getBalance() {
        return balance;
    }
    ...
}
```

<br>

## 객체 생성과 초기화

자바의 객체는 `new` 키워드로 생성할 수 있다. 예를 들어 `A` 라는 클래스에 대한 인스턴스를 생성하고 `A` 타입 참조형 변수 `obj` 에 담는 것은 다음과 같다.

```java
A obj = new A();
```

`new` 키워드는 객체를 생성하고 생성된 객체에 접근할 수 있는 참조값을 반환한다. 따라서 생성된 객체의 참조값을 별도로 저장할 필요가 없는 경우 다음과 같이 사용하는 것도 가능하다.

```java
// A 클래스에 method 라는 메서드가 있다고 가정
new A().method();
```

단 이 경우 생성된 객체의 참조값을 유지하지 않으므로 이후에는 해당 객체를 다시 사용할 수 없다.

> 힙 영역과 GC
>
> 자바의 객체들은 JVM 메모리 영역 중 힙 영역(heap area)에 생성된다. 따라서 객체의 참조값은 힙 영역 어딘가에 생성된 객체에 대한 주소값의 일종으로 볼 수 있다. 더불어 자바의 힙 영역은 GC(garbage collection)에 의해 자동으로 관리되며 더 이상 참조되지 않는 객체는 자동으로 제거된다.

### 필드의 초기값

클래스의 필드는 별도로 초기화하지 않을 경우 정해진 초기값으로 초기화된다. 초기값은 필드의 타입에 따라 다르며 다음과 같다.

| 타입                           | 초기값    |
| ------------------------------ | --------- |
| `byte`, `short`, `int`, `long` | 0, 0L     |
| `float`, `double`              | 0.0F, 0.0 |
| `char`                         | '\u0000'  |
| `boolean`                      | false     |
| 참조형                         | null      |

### 필드 초기화

필드의 값을 지정한 값으로 초기화하려는 경우 필드를 정의할 때 초기값도 함께 지정하면 된다.

```java
class A {
    필드타입 필드이름 = 초기값;
}
```

이 경우 해당 클래스의 모든 인스턴스들은 같은 필드에 대해 같은 값으로 초기화된다.

### 생성자

생성자는 일종의 특수한 메서드로 객체가 생성될 때 초기화를 위해 사용된다. `new` 키워드를 쓸 때 메서드 호출처럼 `()` 이 있는 이유는 생성자가 호출되기 때문에 필요한 경우 매개변수를 넘겨주어야 하기 때문이다.

생성자는 반환타입이 없고(아예 비워둠) 클래스와 이름이 동일한 메서드이다.

```java
class A {
    A(매개변수 목록) {
        // 생성자 본문
    }
}
```

생성자는 일반적으로 필드의 초기화를 위해 사용한다. 필드 초기화 방식은 모든 객체가 동일한 값으로 초기화 되지만 생성자를 사용하면 객체를 생성할 때마다 적절한 값으로 필드를 초기화할 수 있다.

`Account` 클래스의 인스턴스를 생성할 때마다 잔액을 적절한 값으로 초기화할 수 있도록 생성자 정의

```java
class Account {
    int balance = 0;

    public Account(int balance) {
        this.balance = balance;
    }
    ...
}
```

`this` 키워드는 객체 자기자신을 가리키는 참조값이다. 만약 필드나 매개변수(지역변수)가 이름이 겹치는 경우 가까운 쪽이 선택되므로 필드를 가리키기 위해 사용한다.

> 필드 초기화와 생성자
>
> 필드값의 초기화에 필드 초기화 방식과 생성자를 중복해서 적용할 경우 생성자 초기화가 적용된다. 필드 초기화 방식이 무시되는 것은 아니며 둘다 실행되지만 생성자로 초기화된 값이 적용된다. 이는 필드 초기화 방식도 컴파일 과정에서 생성자로 들어가서 개발자가 정의한 생성자 코드보다 먼저 실행되어 상대적으로 나중에 실행되는 생성자 코드가 적용되기 때문이다.

### 생성자 오버로딩

생성자도 오버로딩(overloading)이 가능하며 메서드 오버로딩과 같이 매개변수 타입, 개수를 다르게하면 된다.

```java
class A {
    A() { ... }
    A(int num) { ... }
    A(int num1, int num2) { ... }
    A(double num1, double num2) { ... }
}
```

`Account` 클래스에 매개변수가 없는 생성자와 잔액을 전달받는 생성자 오버로딩

```java
class Account {
    int balance;

    public Account() {
    }

    public Account(int balance) {
        this.balance = balance;
    }
    ...
}
```

각각 오버로딩된 생성자 호출

```java
class AccountMain {

    public static void main(String[] args) {
        Account account1 = new Account();   // Account() { ... } 호출
        Account account2 = new Account(20); // Account(int balance) { ... } 호출
    }
}
```

> 기본 생성자
>
> 자바의 클래스에는 반드시 생성자가 필요한데 생성자를 별도로 정의하지 않아도 컴파일 에러는 나지 않는다. 이는 자바 컴파일러가 정의된 생성자가 하나도 없는 경우 매개변수와 코드 본문이 없는 기본 생성자를 자동으로 만들어주기 때문이다.

### this() 생성자 호출

생성자를 여러개 오버로딩해서 사용할 때 일부 중복되는 코드가 발생할 수 있다. 그 경우 `this()` 를 통해 생성자 내에서 다른 생성자를 호출하는 식으로 코드 중복을 피할 수 있다.

```java
class A {
    A() {
        this(10, 10);  // A(int num1, int num2) { ... } 를 호출
    }

    A(int num1) {
        this(num1, 10) // A(int num1, int num2) { ... } 를 호출
    }

    A(int num1, int num2) { ... }
}
```

`this()` 로 생성자에서 다른 생성자를 호출할 때는 다음 규칙이 적용된다.

- `this()` 는 생성자의 가장 맨 첫줄에만 올 수 있음, 따라서 한 생성자에서 2번 이상 호출하지 못함
- 오버로딩된 생성자 끼리 서로를 `this()` 로 호출 할 수 없음, 무한 호출 방지

`Account` 클래스에 계좌의 가입 상품을 의미하는 필드가 추가된 상태에서 객체 생성 시 해당 필드의 값을 선택적으로 받고 별도로 받지 않는 경우 기본값을 지정하기

```java
class Account {
    int balance;
    String product;

    public Account() {
    }

    // this() 적용전
    // public Account(int balance) {
    //     this.balance = balance;
    //     product = "기본 예금";
    // }

    // this() 적용후
    public Account(int balance) {
        this(balance, "기본 예금");
    }

    public Account(int balance, String product) {
        this.balance = balance;
        this.product = product;
    }
    ...
}
```

<br>

## 객체 접근

생성된 객체에 접근할 때는 해당 객체에 대한 참조값과 `.` 연산자를 사용한다.

```java
A obj = new A();
obj.field;    // 객체의 필드에 접근
obj.method(); // 객체의 메서드 호출
```

<br>

## 접근 제한자

접근 제한자는 클래스 외부에서 멤버에 접근하는 것을 제한하는 키워드로 클래스 수준, 멤버 수준에 적용되며 키워드가 붙는 위치는 다음과 같다.

```java
[접근 제한자] class A {
    [접근 제한자] int num;

    [접근 제한자] void method() { ... }
}
```

- 클래스 수준 접근 제한자(클래스에만 적용)
  - `public` → 공용 클래스, 외부 모든곳에서 접근 가능
  - `package-private` → 같은 패키지 내에서만 접근 가능, 접근 제한자를 명시하지 않을 경우의 기본값
- 멤버 수준 접근 제한자(필드, 메서드, 생성자에 적용)
  - `public` → 공용 멤버, 외부 모든곳에서 접근 가능
  - `private` → 외부에서 접근이 불가능하며 같은 클래스 내에서만 접근 가능
  - `package-private` → 같은 패키지 내에서만 접근 가능, 접근 제한자를 명시하지 않을 경우의 기본값
  - `protected` → 같은 패키지, 상속 받는 서브 클래스에서만 접근 가능

### 클래스 접근 제한자

클래스에 접근 제한자를 적용할 때는 해당 클래스가 정의된 `.java` 파일과 관련된 다음 규칙이 적용된다.

- `.java` 파일 명은 파일 내 정의된 클래스중 `public` 클래스와 같아야 함
- `.java` 파일 내 `public` 클래스는 하나만 정의할 수 있음
- `.java` 파일 내 `package-private` 클래스는 여러개 정의할 수 있음
- `.java` 파일 내 `public` 클래스가 없는 경우 `package-priavte` 클래스 중 하나의 이름을 선택해야 함

### 접근 제한자와 캡슐화

oop의 캡슐화 원칙을 지키며 장점을 살리기 위해서는 필드는 숨기고 메서드는 노출하여 메서드를 통해 외부에서 접근하도록 해야한다. 접근 제한자를 사용해서 프로그램에 적절한 제약을 설정하면 캡슐화의 이점을 살릴 수 있다.

`Account` 클래스는 `balance` 필드가 `package-private` 로 노출되어 같은 패키지에서 조작이 가능한 상태로 캡슐화가 깨져있다.

```java
class Account {
    int balance;

    void deposit(int amount) {
        balance += amount;
    }
    ...
}
```

`balance` 필드를 `private` 로 변경해서 외부에 숨기고 입금, 출금, 잔액확인 메서드를 별도로 만들고 `public` 으로 노출시키는 쪽으로 개선하면 다음과 같다.

```java
class Account {
    private int balance;
    ...
    void deposit(int amount) {
        balance += amount;
    }

    public void withdraw(int amount) {
        if (isValidAmount(amount)) {
            balance -= amount;
        }
    }

    public int getBalance() {
        return balance;
    }

    private boolean isValidAmount(int amount) {
        return !(balance < amount);
    }
    ...
}
```

- `balance` 필드를 `private` 로 하여 외부에 숨기고 `deposit()`, `withdraw()` 메서드를 통해서만 값이 변경되도록 함
- 잔액보다 많은 금액을 출금하는 잘못된 상황을 메서드 내부에서 검증을 통해 방지
- 외부에서 필요하지 않은 기능인 `isValidAmount()` 메서드는 `private` 로 하여 외부로 숨김으로써 사용자에게는 필요한 기능만 제공

<br>

## References

- [김영한의 실전 자바 - 기본편 - 김영한, Inflearn](https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EA%B8%B0%EB%B3%B8%ED%8E%B8)
- [Java Language Specification se21 #ch8 - Oracle](https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html)
- [Objects, Classes, Interfaces, Packages, and Inheritance - Dev.java](https://dev.java/learn/oop/)
- [Creating Classes - Dev.java](https://dev.java/learn/classes-objects/creating-classes/)

<br>

## Tags

- java
- class
- oop
- field
- method
- constructor
