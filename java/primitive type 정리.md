# primitive type 정리

자바에서 제공하는 8가지 primitive type 정리

## TOC

- [primitive type 개요](#primitive-type-개요)
  - [primitive type 특징](#primitive-type-특징)
- [숫자형](#숫자형)
  - [정수형](#정수형)
    - [정수형 크기와 표현 범위](#정수형-크기와-표현-범위)
    - [정수형의 메모리 표현](#정수형의-메모리-표현)
    - [정수 리터럴](#정수-리터럴)
    - [정수형 사용빈도](#정수형-사용빈도)
  - [문자형](#문자형)
    - [문자형 크기와 표현 범위](#문자형-크기와-표현-범위)
    - [문자형의 특징](#문자형의-특징)
    - [문자형의 메모리 표현](#문자형의-메모리-표현)
    - [문자형 리터럴](#문자형-리터럴)
  - [실수형](#실수형)
    - [실수형 크기와 표현 범위](#실수형-크기와-표현-범위)
    - [실수형의 메모리 표현](#실수형의-메모리-표현)
    - [실수형 리터럴](#실수형-리터럴)
    - [실수형 정밀도와 오차 문제](#실수형-정밀도와-오차-문제)
    - [실수형 사용빈도](#실수형-사용빈도)
- [논리형](#논리형)
  - [논리형 크기와 표현 범위](#논리형-크기와-표현-범위)
  - [논리형 리터럴](#논리형-리터럴)

<br>

## primitive type 개요

primitive type은 자바 언어 수준에서 미리 정의된 8가지 데이터 타입으로 7개의 숫자형과 1개의 논리형으로 구성된다.

- 숫자형
  - `byte`, `short`, `char`, `int`, `long`, `float`, `double`
- 논리형
  - `boolean`

### primitive type 특징

- 각 타입의 이름이 예약어(keyword)로 지정되어 있음
- 변수가 값 자체를 가지며 다른 변수와 공유하지 않음

<br>

## 숫자형

primitive type의 7가지 숫자형은 3종류로 구분할 수 있으며 저장할 데이터와 데이터 저장을 위한 메모리 사용 방식에 차이점이 있다.

- 정수형
- 문자형
- 실수형

### 정수형

정수형 primitive type은 정수를 나타내기 위한 타입으로 `byte`, `short`, `int`, `long` 이 있다.

#### 정수형 크기와 표현 범위

각 타입별 크기와 표현 범위

- `byte` → 8 bit(1 byte), -128 ~ 127
- `short` → 16 bit(2 byte), -32,768 ~ 32,767
- `int` → 32 bit(4 byte), -2,147,483,648 ~ 2,147,483,647
- `long` → 64 bit(8 byte), -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807

#### 정수형의 메모리 표현

정수형 primitive type은 메모리에서 최상위 1 bit에 부호를 저장하고(부호 bit) 나머지 bit에 정수의 절대값을 저장한다.

- 최상위 1 bit는 부호저장(0 양수, 1 음수)
- 나머지 bit는 정수의 절대값을 저장
  - 양수의 경우 절대값을 그대로 저장
  - 음수의 경우 절대값의 2의 보수를 저장(회로 구성과 연산의 이점을 위함)

```console
# 127의 표현
   +---+      +---+---+---+---+---+---+---+
   | 0 |      | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
   +---+      +---+---+---+---+---+---+---+
# 부호 bit                # 절대값


# -128의 표현
   +---+      +---+---+---+---+---+---+---+
   | 1 |      | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
   +---+      +---+---+---+---+---+---+---+
# 부호 bit            # 절대값(2의 보수)
```

#### 정수 리터럴

정수 리터럴은 소스코드에 나타나는 고정된 정수 값이다.

```java
// int 리터럴
byte num1 = 127;
short num2 = 32767;
int num3 = 2147483647;

// long 리터럴
long num4 = 10000000000L;

// hex, dec, oct, bin 리터럴, 각각 777,777의 진법만 다른 표현
int hex = 0xbde31;
int dec = 777777;
int oct = 02757061;
int bin = 0b10111101111000110001;

// '_' 이용한 리터럴
int balance1 = 1000000000;    // 10억
int balance2 = 1_000_000_000; // 10억
```

- 별도의 접미사 없이 사용된 정수 리터럴은 `int` 타입으로 취급
- `L`, `l` 접미사가 붙은 경우 `long` 타입으로 취급, `int` 범위를 벗어나는 큰 수를 그냥 쓸 경우 컴파일 에러
- `0x | 0X`, `0`, `0b | 0B` 를 리터럴에 접두사로 붙이는 경우 각각 16진수, 8진수, 2진수로 취급
  - 2진수 리터럴의 경우 JDK 7부터 지원
- 자릿수 구분을 위한 `_` 를 숫자 사이에 추가할 수 있음

#### 정수형 사용빈도

- `int` 타입이 대부분의 경우에 사용됨, 정수형 연산이 기본적으로 `int` 로 처리
- `int` 크기를 넘어가는 매우 큰 정수를 표현해야 하는 경우 `long` 타입 사용
- 파일 처리 등에서 `byte` 타입 사용

### 문자형

문자형 primitive type은 문자 하나를 나타내기 위한 타입으로 `char` 가 있다.

#### 문자형 크기와 표현 범위

자바의 문자형은 unicode 문자를 나타낼 수 있으며 UTF-16 인코딩을 기준으로 한다.

- `char` → 16 bit(2 byte), '\u0000' ~ '\uffff'(0 ~ 65,535)

#### 문자형의 특징

- `char` 의 표현하는 범위는 unicode의 기본 다국어 평면(bmp)에 해당함
  - unicode 기본 다국어 평면(bmp)에는 숫자, 영어, 한글, 한자 등 대부분의 일상적인 언어가 포함됨
- 양수 정수를 저장할 수 있으므로 크게보면 정수형에 포함되나 음수는 저장하지 못함

#### 문자형의 메모리 표현

자바의 문자형 표현은 UTF-16으로 인코딩된 unicode 문자를 16 bit에 저장한다.

```console
# '가' 표현
   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
   | 1 | 0 | 1 | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
# '가'의 UTF-16값
  # 1010110000000000₍₂₎ 실제 저장되는 값
  # 44,032₍₁₀₎
  # 0xAC00₍₁₆₎
```

#### 문자형 리터럴

문자 리터럴은 소스코드에 나타나는 고정된 문자 값이다.

```java
// '' 단일 문자 리터럴
char ch1 = 'A';

// unicode escape hex
char ch2 = '\u0041'; // '\u0041' → 'A'

// escape sequence
char ch3 = '\n'; // 줄바꿈 문자

// octal escape
char ch4 = '\101'; // \101 (oct) → 'A'

// 숫자 리터럴
char ch5 = 65;   // 65 → 'A'
char ch6 = 0x41; // 0x41 → 'A'

```

- `' '` 로 감싼 단일 문자
  - `\u` 접두사가 붙는 16진수를 통한 unicode escape
  - `\n` 등의 escape sequence
  - `\` 접두사가 붙는 8진수를 통한 unicode escape, 사용빈도 낮음(C 호환성을 위해 제공)
- `char` 범위 내 정수 리터럴을 사용가능 (정수값을 적절한 unicode 문자로 처리함)

### 실수형

실수형 primitive type은 실수를 나타내기 위한 타입으로 `float`, `double` 이 있다.

#### 실수형 크기와 표현 범위

각 타입별 크기와 표현 범위

- `float` → 32 bit(4 byte), ±3.4E38 ~ ±3.4E38, 7자리 정밀도(10진수 기준)
- `double` → 64 bit(8 byte), ±1.7E308 ~ ±1.7E308, 15자리 정밀도(10진수 기준)

> 소수점 이하의 숫자는 무한대로 늘어날 수 있으므로 실수형의 표현 범위는 근사치이다.

#### 실수형의 메모리 표현

자바의 실수형 표현은 정규화된 실수를 3부분으로 나누어 저장하는 IEEE 754 표준 방식을 따르고 있다.

- 부호 1 bit(0 양수, 1 음수)
- 지수부 (`float` 는 8 bit, `double` 은 11 bit)
- 가수부 (`float` 는 23 bit, `double` 은 52 bit)

10진수 실수를 정규화하여 bit의 각 부분에 나누어 저장하는 과정

1. 음수, 양수에 따라 부호 비트 저장
2. 실수의 절대값을 2진수로 변환
3. 소수점을 이동하여 정수 자리에 1만 남도록 함, 예 1110110.101₍₂₎ = 1.110110101₍₂₎ x 2⁶ → 지수: 6, 소수점 이하: 110110101
4. 지수에 bias 값을 더하고 2진수로 변환하여 가수부에 저장
5. 소수점 이하 부분을 가수부의 왼쪽부터 채우고 남는 비트는 0으로 채움

```console
# −118.625의 표현 (-1110110.101₍₂₎), float 기준
   +---+      +---+---+---+---+---+---+---+---+    +---+---+---+---+---+---+---+---+---+     +---+---+---+---+
   | 1 |      | 1 | 0 | 0 | 0 | 0 | 1 | 0 | 1 |    | 1 | 1 | 0 | 1 | 1 | 0 | 1 | 0 | 1 | ... | 0 | 0 | 0 | 0 |
   +---+      +---+---+---+---+---+---+---+---+    +---+---+---+---+---+---+---+---+---+     +---+---+---+---+
# 부호 비트               # 지수부 (8 bit)                                  # 가수부 (23 bit)
```

> 부동소수점의 이러한 표현방식으로 인해 `float`, `double` 은 정수형에 비해 훨씬 넓은 범위의 값을 저장할 수 있다. 실제로 `long` 보다 `float` 이 더 적은 메모리를 사용하지만 표현 범위는 더 넓다.

> 부동소수점의 표현에서 지수를 그대로 저장하지 않고 bias를 더하는 이유는 음수 지수와 양수 지수를 모두 양수 범위에 들어오도록 하기 위해서이다. 이를 통해 비교 연산등에서 이점을 얻을 수 있다.

#### 실수형 리터럴

실수 리터럴은 소스코드에 나타나는 고정된 실수 값이다.

```java
// float 리터럴
float num1 = 3.14F;

// double 리터럴
double num2 = 3.14; // 3.14D, D는 생략가능

// e (10의 지수 표현)를 사용하는 리터럴
double num3 = 0.0314e+2; // 3.14, 양수 지수(+ 생략가능)
double num4 = 314.0e-2;  // 3.14, 음수 지수

// p (2의 지수 표현)를 사용하는 리터럴
double num5 = 0x1.91eb851eb851fp+1; // 3.14

// hex, dec 리터럴, 각각 3.14의 진법만 다른 표현
double hex = 0x1.91eb851eb851fp1; // 16진수 일 경우 e(10의 지수) 대신 p(2의 지수) 사용
double dec = 3.14;

// '_' 이용한 리터럴
double maxDouble1 = 0x1.fffffffffffffP+1023;
double maxDouble2 = 0x1.f_ffff_ffff_ffffP+1023;
```

- `F`, `f` 접미사가 붙은 경우 `float` 타입으로 취급
- `D`, `d` 접미사가 붙은 경우 `double` 타입으로 취급, 단 접미사가 없는 실수 리터럴은 기본적으로 `double` 이므로 생략가능
- `0x | 0X` 를 리터럴에 접두사로 붙이는 경우 16진수로 취급
- `e | E`, `p | E` 를 사용하는 과학적 표기법 사용 가능
  - 기호 앞에 `+ | -` 로 지수의 양수, 음수 표기 가능, `+` 는 생략가능
  - 10진수 표기시 10의 지수로 `e | E` 사용
  - 16진수 표기시 2의 지수로 `p | P` 사용
- 자릿수 구분을 위한 `_` 를 숫자 사이에 추가할 수 있음

#### 실수형 정밀도와 오차 문제

부동소수점 자체의 특성상 실수를 표현하는 과정에서 값의 오차가 발생할 수 있다. 타입별로 정확하게 표현할 수 있는 자리수가 있으며 이 이상의 경우 오차가 발생할 수 있다.

- `float`, 7자리 (10진수 기준)
- `double`, 15자리 (10진수 기준)

이 자리수를 넘어가는 경우 반올림으로 처리하기 때문에 정확한 값을 기대할 수 없다.

```java
// float 타입의 정밀도 문제, 유효 범위 7자리를 넘어가서 생기는 문제점
float num1 = 9.234567890123456F;
System.out.printf("num1 = %.10f\n", num1); // num1 = 9.2345676422

// double 타입의 정밀도 문제, 유효 범위 15자리를 넘어가서 생기는 문제점
double num2 = 9.234567890123456789;
System.out.printf("num1 = %.20f\n", num2); // num1 = 9.23456789012345600000
```

부동소수점 표현 방식의 정확한 자리수는 해당 자리수까지만 유효하므로 그 이상의 자리수까지 연산에 포함될 경우 오차가 발생할 수 있다.

```java
float num1 = 0.1F;
System.out.println("num1 = " + num1);      // num1 = 0.1, 특정 범위만 보면 정확함
System.out.printf("num1 = %.10f\n", num1); // num1 = 0.1000000015, 실제 값은 오차 발생

float score = 0.0F;
for (int i = 0; i < 10; i++) {
    score += 0.1F;
}
System.out.println("score = " + score); // score = 1.0000001, 1,0이 아님!
```

`float` 타입에서 `0.1` 자체는 오차없이 정확하게 나타나는 것으로 보이지만 실제 저장된 값은 `0.1000000015` 로 오차가 있다. 따라서 계산결과가 정확하지 않다.

> `float`, `double` 은 부동소수점 표현 방식에 의한 본질적인 정밀도 문제를 가지기 때문에 정확한 값이 필요한 경우에는 사용할 수 없다. 이는 자바 뿐 아니라 IEEE 754 부동소수점 표현 방식을 채택한 다른 언어도 마찬가지다. 실수 계산에서 정확한 값이 필요한 경우에는 각 언어에서 제공하는 전용 API를 사용하도록 하자. 자바의 경우 `BigDecimal` 클래스를 쓰면 된다.

#### 실수형 사용빈도

- `double` 타입이 대부분의 경우에 사용됨, `float` 대비 더 높은 정밀도와 표현 범위를 가짐
- 단 본질적인 정밀도 문제가 있으므로 정확한 계산이 필요하면 `BigDecimal` 사용

<br>

## 논리형

자바는 `ture`, `false` 의 논리값을 나타내기 위한 타입으로 `boolean` 을 제공한다.

### 논리형 크기와 표현 범위

- `boolean` → 크기 미정, `true` 또는 `false`

> `boolean` 타입은 `true`, `false` 두 가지 종류만 나타내기 때문에 1 bit로도 충분하지만 스펙상으로 정확한 크기가 정의되어 있는것은 아니다.

### 논리형 리터럴

```java
boolean isTrue = true;
boolean isFalse = false;
```

- `true | false` 의 단 두가지 리터럴만 가짐

<br>

## References

- [Java Language Specification se21 #ch4 - Oracle](https://docs.oracle.com/javase/specs/jls/se21/html/jls-4.html)
- [Creating Primitive Type Variables in Your Programs - Dev.java](https://dev.java/learn/language-basics/primitive-types/)
- [김영한의 자바 입문 - 코드로 시작하는 자바 첫걸음 - 김영한, Inflearn](https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%9E%90%EB%B0%94-%EC%9E%85%EB%AC%B8)
- [이것이 자바다 #2장 - 신용권, 한빛미디어](https://www.hanbit.co.kr/store/books/look.php?p_code=B1460673937)
- [The Java™ Tutorials #Primitive Data Types - Oracle](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)
