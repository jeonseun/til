# 연산자 기본 개념

연산자 기본 개념 정리

## TOC

- [연산자 개요](#연산자-개요)
- [연산자 우선순위](#연산자-우선순위)
  - [명시적 우선순위 지정](#명시적-우선순위-지정)
  - [연산자 우선순위 주의사항](#연산자-우선순위-주의사항)
- [단순 할당 연산자](#단순-할당-연산자)
- [부호 연산자](#부호-연산자)
- [산술 연산자](#산술-연산자)
  - [곱셈 연산자](#곱셈-연산자)
  - [덧셈 연산자](#덧셈-연산자)
  - [산술 연산자 타입처리](#산술-연산자-타입처리)
  - [정수 오버플로](#정수-오버플로)
  - [0 으로 나누기](#0-으로-나누기)
  - [NaN \& Infinity](#nan--infinity)
  - [% 연산자 반환값 부호](#-연산자-반환값-부호)
- [문자열 접합 연산자](#문자열-접합-연산자)
- [증감 연산자](#증감-연산자)
  - [전위, 후위 연산자](#전위-후위-연산자)
- [관계 연산자](#관계-연산자)
  - [수치 비교 연산자](#수치-비교-연산자)
  - [동등 연산자](#동등-연산자)
- [조건/논리 연산자](#조건논리-연산자)
- [비트 연산자](#비트-연산자)
  - [비트 단위 연산자(integer)](#비트-단위-연산자integer)
  - [비트 단위 연산자(boolean)](#비트-단위-연산자boolean)
  - [시프트 연산자](#시프트-연산자)
- [복합 할당 연산자](#복합-할당-연산자)

<br>

## 연산자 개요

연산자(operator)는 몇 개의 피연산자(operand)에 대해 연산을 수행하고 결과값을 반환하는 특수한 기호를 말한다. 연산자의 특징은 다음과 같다.

- 1 ~ 3개의 피연산자가 필요
- 1개의 연산결과 반환
- 연산자 별로 피연산자 타입이 다름
- 반환값과 더불어 부수 효과(side effect)가 발생하는 연산자도 있음

<br>

## 연산자 우선순위

연산자는 처리되는 순서, 즉 우선순위가 정해져있으며 연산자가 여러 개 있을 때 우선순위가 높은 연산자가 먼저 처리된다. 우선순위를 표로 나타내면 다음과 같으며 아래로 갈수록 우선순위가 낮아진다.

| 구분                                                         | 연산자                                                                    |
| ------------------------------------------------------------ | ------------------------------------------------------------------------- |
| 증감 연산자, 부호 연산자, 비트 반전 연산자, 논리 부정 연산자 | `++`, `--`, `+`, `-`, `~`, `!`                                            |
| 곱셈 연산자                                                  | `*`, `/`, `%`                                                             |
| 덧셈 연산자                                                  | `+`, `-`                                                                  |
| 시프트 연산자                                                | `>>`, `<<`, `>>>`                                                         |
| 수치 비교 연산자                                             | `>`, `>=`, `<`, `<=`, `instanceof`                                        |
| 동등 연산자                                                  | `==`, `!=`                                                                |
| 비트 AND 연산자                                              | `&`                                                                       |
| 비트 XOR 연산자                                              | `^`                                                                       |
| 비트 OR 연산자                                               | `\|`                                                                      |
| 조건부 AND 연산자                                            | `&&`                                                                      |
| 조건부 OR 연산자                                             | `\|\|`                                                                    |
| 삼항 연산자                                                  | `? :`                                                                     |
| 할당 연산자                                                  | `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `^=`, `!=`, `>>=`, `<<=`, `>>>=` |

식에서 연산자들이 우선순위가 같다면 왼쪽에서 오른쪽으로 차례대로 연산자를 처리한다. 단 할당 연산자는 오른쪽에서 왼쪽으로 처리된다.

```java
// 1. 10 / 2 → 5
// 2. 5 + 5 → 10
System.out.println(5 + 10 / 2);

// 1. ~5 → -6
// 2. -6 == 20 → false
System.out.println(~5 == 20);

// 1. 20 * 5 → 10
// 2. 10 + 10 → 20
// 3. int num = 20 → 20, num에 20 할당
int num = 20 * 5 + 10;
```

### 명시적 우선순위 지정

`()` 기호를 사용하면 연산자 우선순위를 명시적으로 지정할 수 있다. `()` 기호로 감싼 연산식은 우선순위가 높아져서 먼저 처리된다. 만약 `()` 를 여러개 쓸 경우 왼쪽부터 처리한다.

```java
// 1. 5 * 20 → 100
// 2. 10 + 100 → 110
System.out.println(10 + 5 * 20);

// 1. (10 + 5) → 15
// 2. 15 * 20 → 300
System.out.println((10 + 5) * 20);
```

### 연산자 우선순위 주의사항

연산자 우선순위를 잘못 생각하면 연산식의 결과가 기대값과 달라질 수 있으므로 우선순위를 잘 파악해야 한다. 연산자 우선순위와 관련해서는 다음 사항을 참고하자.

- 일반적인 상식선에서 우선순위 파악하기
  - 수학처럼 덧셈보다 곱셈이 먼저 처리됨
  - 계산을 끝마치고 할당 하는 것이 일반적
  - 두 조건식의 논리적 비교에 앞서 두 식이 먼저 처리되어야 함
  - etc...
- 혼동할 여지가 있는 경우 `()` 로 명시적으로 우선순위 표기하기
  - 연산식이 짧은 경우를 제외하고 기본적인 연산자 우선순위에 의존하는 것은 좋지 않음
  - `()` 를 통해 먼저 처리될 연산식을 명확하게 하는 것이 가독성, 에러 예방에 효과적

<br>

## 단순 할당 연산자

단순 할당 연산자(simple assignment operator)는 변수에 특정값을 할당하는 연산자로 `=` 기호를 사용하며 2개의 피연산자가 필요하다.

```java
// 기본형태: 피연산자(변수) = 피연산자
int num = 10;
```

할당 연산자의 왼쪽 피연산자는 반드시 변수여야 하며 오른쪽 피연산자는 해당 변수와 호환되는 어떤타입도 가능하다.

```java
20 = 30;           // 컴파일 에러, 왼쪽 피연산자가 변수가 아님
int intNum = 3.14; // 컴파일 에러, 호환 불가능한 타입
```

할당 연산자는 오른쪽 피연산자의 값을 반환하며 부수 효과로 왼쪽 피연산자에 오른쪽 피연산자의 값을 할당한다.

```java
int num = 10;
System.out.println("num = " + num);               // num = 10
System.out.println("(num = 20) = " + (num = 20)); // (num = 20) = 20
```

<br>

## 부호 연산자

부호 연산자(sign operator)는 숫자 타입의 부호를 결정하는 연산자로 1개의 피연산자에 사용할 수 있고 숫자 타입 또는 호환되는 타입에만 사용할 수 있다.

- `+` → 피연산자를 양수로 취급, 기본값
- `-` → 피연산자를 음수로 취급

```java
// 기본형태: +피연산자 | -피연산자
int num = +10; // +10, 기본값 +, 생략가능
System.out.println("num = " + num); // num = 10
num = -10;     // -10
System.out.println("num = " + num); // num = -10
```

부호 연산자는 해당 부호가 적용된 숫자 값을 반환한다. 이는 피연산자가 변수인 경우에도 동일하게 적용된다.

```java
int val1 = 10;
System.out.println("val1 = " + val1); // val1 = 10
int val2 = -val1;
System.out.println("val2 = " + val2); // val2 = -10
```

자바에서는 0에서 피연산자를 빼는 방식으로 `-` 를 처리한다. 따라서 음수와 양수의 범위가 대칭이 아닌 정수 타입(`int`, `long`)의 최소값에 `-` 부호 연산자를 사용하면 부호가 바뀌지 않고 기존값과 같은 값이 나오게된다.

```java
int min = Integer.MIN_VALUE;          // int 최소값 -2147483648
System.out.println("min  = " + min);  // min  = -2147483648
System.out.println("-min = " + -min); // -min = -2147483648
```

> 부호 연산자를 조금 다르게 보면 `+` 는 현재 부호를 유지하는 연산자, `-` 는 현재 부호를 반전시키는 연산자로 볼 수 있다. 이를 응용하면 `-` 연산자를 사용해서 +, -를 토글할 수 있다.
>
> ```java
> int num = 10;
> num = -num;
> System.out.println("num = " + num); // num = 10
> num = -num;
> System.out.println("num = " + num); // num = -10
> ```

<br>

## 산술 연산자

산술 연산자(arithmetic operator)는 덧셈, 뺄셈, 곱셈, 나눗셈의 일반적인 4칙 연산과 나머지 연산에 대한 연산자를 말한다. 2개의 피연산자를 받으며 숫자 타입 또는 호환되는 타입에만 사용할 수 있다.

산술 연산은 특징에 따라 곱셈 연산자(multiplicative operators)와 덧셈 연산자(additive operators)로 구분할 수 있다.

- 곱셈 연산자
  - 곱셈 연산자(multiplication operator), `*`
  - 나눗셈 연산자(division operator), `/`
  - 나머지 연산자(remainder operator), `%`
- 덧셈 연산자
  - 덧셈 연산자(addition operator), `+`
  - 뺄셈 연산잔(subtraction operator), `-`

### 곱셈 연산자

- `A * B` → A, B의 곱을 반환
- `A / B` → A를 B로 나눌때의 몫을 반환
- `A % B` → A를 B로 나눈 나머지를 반환

```java
int num1 = 10;
int num2 = 3;
System.out.println("num1 * num2 = " + (num1 * num2)); // num1 * num2 = 30
System.out.println("num1 / num2 = " + (num1 / num2)); // num1 / num2 = 3
System.out.println("num1 % num2 = " + (num1 % num2)); // num1 % num2 = 1
```

### 덧셈 연산자

- `A + B` → A, B의 합을 반환
- `A - B` → A에서 B를 뺀 값을 반환

```java
int num1 = 10;
int num2 = 3;
System.out.println("num1 + num2 = " + (num1 + num2)); // num1 + num2 = 13
System.out.println("num1 - num2 = " + (num1 - num2)); // num1 - num2 = 7
```

### 산술 연산자 타입처리

자바에서는 피연산자의 타입을 일치시킨 뒤 산술 연산자를 처리한다. 피연산자 간 타입이 다를 경우 타입을 일치시키기 위해 타입 승격(type promotion)이 일어나며 반환값도 승격된 타입을 따르게 된다. 이는 시프트 연산자를 제외한 숫자 관련 연산자에 공통으로 적용된다.

타입 승격 규칙

- 피연산자 중 가장 큰 타입에 맞춰서 작은 타입이 승격됨
- 단 피연산자가 `byte`, `short`, `char`, `int` 타입으로만 구성될 경우 `int` 타입으로 승격 후 처리됨

```java
double doubleVal = 10.0;
float floatVal = 3.1F;
long longVal = 1_000_000_000_000L;
int intVal = 1000;
byte byteVal = 10;
short shortVal = 10;
char charVal = 5;

// double 타입 피연사자가 포함되는 경우, double promotion
double doubleResult = doubleVal + intVal;
System.out.println("doubleVal + intVal = " + doubleResult); // doubleVal + intVal = 1010.0

// float 타입 피연산자가 포함되는 경우, float promotion
float floatResult = floatVal + longVal;
System.out.println("floatVal + longVal = " + floatResult); // floatVal + longVal = 1.0E12

// long 타입 피연산자가 포함되는 경우, long promotion
long longResult = longVal + intVal;
System.out.println("longVal + intVal = " + longResult); // longVal + intVal = 1000000001000

// byte, short, char, int 타입 피연산자만 포함되는 경우, int promotion
int intResult = byteVal + shortVal + charVal;
System.out.println("byteVal + shortVal + charVal = " + intResult); // byteVal + shortVal + charVal = 25
```

> 숫자 타입 간 크기 순서 (왼쪽부터 작은순)
>
> `byte` → `short`, `char` → `int` → `long` → `float` → `double`

### 정수 오버플로

정수 오버플로(integer overflow)는 정수 타입 피연산자에 대해서 연산자의 처리 결과가 반환 타입의 범위를 벗어나는 경우 수학적 계산 결과와 반환값이 달라지는 현상을 말한다. 정수 타입이 메모리를 쓸 때 최상위 1 비트를 부호 비트로 쓰기 때문에 계산 과정에서 부호 비트까지 올림이 발생할 경우 부호 비트가 영향을 받으면서 결과가 수학적 계산 결과와 달라지게 된다. 또한 정수 오버플로는 예외가 발생하지 않으므로 주의해야한다.

정수 최대값에서 값이 더 커지도록 하거나 최소값에서 값이 더 작아지도록 하는 경우 오버플로가 발생한다.

```java
int max = Integer.MAX_VALUE;
System.out.println("max + 1 = " + (max + 1)); // max + 1 = -2147483648
int min = Integer.MIN_VALUE;
System.out.println("min - 1 = " + (min - 1)); // min - 1 = 2147483647
```

부호 연산자에서 정수 타입 최소값에 `-` 를 취했을 때 부호가 바뀌지 않고 같은 부호가 나오는 현상도 오버플로이다.

```java
int min = Integer.MIN_VALUE;           // Integer.MIN_VALUE = -2147483648
System.out.println("-min = " + -min);  // -min = -2147483648, 정수 오버플로
```

피제수가 정수 타입 최소값이고 제수가 -1일 때의 `/` 연산에서 결과값은 부호 변동없이 피제수와 같은 값이 나오는데 이 또한 오버플로로 인한 것이다.

```java
// 정수 타입 최소값 / -1
int min = Integer.MIN_VALUE;
System.out.println("min / -1 = " + (min / -1)); // min / -1 = -2147483648
```

> 부동소수점 언더플로(floating-point underflow)
>
> 부동소수점 피연산자를 대상으로 연산의 결과가 표현 범위를 벗어나는 매우 작은 값인 경우(절대값 기준으로 작음을 의미함, 즉 0에 매우 가까운 소수) 반올림을 통해 근사치를 계산하므로 정확한 계산 결과가 나오지 않는 현상을 부동소수점 언더플로라 한다.

### 0 으로 나누기

정수 타입 피연산자 기준으로 `/`, `%` 에서 제수로 쓰는 피연산자가 0인 경우 `ArithmeticException` 이 발생하므로 0으로 나누는 연산은 수행할 수 없다.

```java
int num = 100;
System.out.println("num / 0 = ?" + (num / 0)); // throw ArithmeticException!!!
System.out.println("num % 0 = ?" + (num % 0)); // throw ArithmeticException!!!
```

### NaN & Infinity

`NaN` 과 `Infinity` 은 부동소수점의 특수한 값이다. 각각 다음 의미를 지닌다.

- `NaN` → Not a Number, 연산 자체가 잘못된 경우의 반환값 (0.0 / 0.0 등)
- `Infinity` → 무한대, 연산의 결과값이 최대/최소값을 넘어가는 경우의 반환값, +, - 구분이 있음

```java
// NaN이 나오는 몇 가지 케이스
double infinity = Double.POSITIVE_INFINITY;
System.out.println("Infinity * 0.0      = " + (infinity * 0.0));      // Infinity * 0.0      = NaN
System.out.println("0.0 / 0.0           = " + (0.0 / 0.0));           // 0.0 / 0.0           = NaN
System.out.println("Infinity / Infinity = " + (infinity / infinity)); // Infinity / Infinity = NaN
System.out.println("Infinity % 10.0     = " + (infinity % 10.0));     // Infinity % 10.0     = NaN
System.out.println("10.0 % 0            = " + (10.0 % 0.0));          // 10.0 % 0            = NaN

// Infinity가 나오는 몇 가지 케이스
double doubleMax = Double.MAX_VALUE;
System.out.println("doubleMax * 2  = " + (doubleMax * 2));   // doubleMax * 2  = Infinity
System.out.println("doubleMax * -2 = " + (doubleMax * - 2)); // doubleMax * -2 = -Infinity
```

`NaN` 과 `Infinity` 가 피연산자에 포함될 경우 연산의 결과는 `NaN` 또는 `Infinity` 만 나오게 된다. 해당 두 값을 직접 사용할 일은 거의 없지만 연산식이 복잡한 경우 특정 연산식의 결과값에 `NaN` 또는 `Infinity` 가 포함될 수 있으므로 주의해야 한다.

```java
// NaN이 포함되는 경우
System.out.println("NaN + 0 = " + (Double.NaN + 0)); // NaN + 0 = NaN
System.out.println("NaN - 0 = " + (Double.NaN - 0)); // NaN - 0 = NaN
System.out.println("NaN * 0 = " + (Double.NaN * 0)); // NaN * 0 = NaN
System.out.println("NaN / 0 = " + (Double.NaN / 0)); // NaN / 0 = NaN
System.out.println("NaN % 0 = " + (Double.NaN % 0)); // NaN % 0 = NaN

// Inifnity가 포함되는 경우
System.out.println("Infinity + 0    = " + (Double.POSITIVE_INFINITY + 0));  // Infinity + 0    = Infinity
System.out.println("Infinity - 1    = " + (Double.POSITIVE_INFINITY - 1));  // Infinity - 1    = Infinity
System.out.println("Infinity * (-1) = " + (Double.POSITIVE_INFINITY * -1)); // Infinity * (-1) = -Infinity
System.out.println("Infinity / (-1) = " + (Double.POSITIVE_INFINITY / -1)); // Infinity / (-1) = -Infinity
```

### % 연산자 반환값 부호

`%` 연산자의 반환값 부호는 제수와 관계없이 피제수에 의해 결정된다.

```java
// % 의 반환 타입
System.out.println("10 % 1   = " + (10 % 1));   // 10 % 1   = 0
System.out.println("10 % -1  = " + (10 % -1));  // 10 % -1  = 0
System.out.println("-10 % 1  = " + (-10 % 1));  // -10 % 1  = 0
System.out.println("-10 % -1 = " + (-10 % -1)); // -10 % -1 = 0
```

<br>

## 문자열 접합 연산자

산술 연산자 `+` 는 피연산자가 문자열(`String`)일 경우 문자열 접합 연산자(string concatenetion operator)로 동작한다. 왼쪽 피연산자와 오른쪽 피연산자를 이어 붙인 문자열을 반환한다. 만약 피연산자 중 다른 하나가 문자열이 아닌경우 문자열로 변환하여 처리한다.

```java
String name = "seun ";
int height = 177;
String info = name + height;
System.out.println(info);  // seun 177
```

`+` 연산자가 여러개 있고 피연산자에 문자열과 숫자가 혼재된 경우 `+` 는 산술 연산자와 문자열 접합 연산자 둘다로 동작할 수 있으므로 주의해야 한다.

```java
// + 가 문자열 접합 연산자로만 사용된 예
System.out.println("string..."  + 10 + 22);   // string...1022
// + 가 산술 연산자와 문자열 접합 연산자 둘 모두로 사용된 예
System.out.println("string..."  + (10 + 22)); // string...32
```

<br>

## 증감 연산자

증감 연산자(increment/decrement operator)는 숫자 타입 변수의 값을 1 만큼 증감 시키는 연산자로 변수의 값을 읽고 1을 증감시킨 뒤 다시 변수에 할당하는 작업을 축약해둔 형태라고 할 수 있다. 숫자 타입 또는 호환되는 타입에만 사용할 수 있으며 피연산자는 반드시 변수여야 하고 반환값은 변수가 아닌 값이다.

- `++` → 1 증가
- `--` → 1 감소

```java
int num = 0;
num++; // num = num + 1;
System.out.println("num = " + num); // num = 1

num = 0;
num--; // num = num - 1;
System.out.println("num = " + num); // num = -1
```

### 전위, 후위 연산자

증감 연산자는 피연산자의 앞 또는 뒤에 올 수 있는데 1을 증감 시킨다는 사실은 같지만 반환값에 차이가 있다.

- 전위 연산자(prefix operator) `++피연산자`, `--피연산자` → 피연산자의 값을 1 증감시키고 증감된 값을 반환
- 후위 연산자(postfix operator) `피연산자++`, `피연산자++` → 피연산자의 값을 1 증감시키고 증감되기 전의 값을 반환

```java
// prefix operator
int num = 0;
System.out.println("++num = " + ++num); // ++num = 1

// postfix operator
num = 0;
System.out.println("num++ = " + num++); // num++ = 0
```

`++num` 은 증감된 값이 반환된 반면 `num++` 는 증감되기 전 원래 값이 반환된 것을 알 수 있다. 단순히 변수의 값을 1 증감시키는 용도로 쓸 경우 두 방식은 차이가 없지만 복잡한 연산식에서 사용할 때는 결과값에 영향을 줄 수 있으므로 주의해야 한다.

<br>

## 관계 연산자

관계 연산자(relational operator)는 두 피연산자를 비교하는 연산자이며 비교 결과로 `boolean` 타입 값을 반환한다.

- 수치 비교 연산자(numerical comparison operator) `>`, `>=`, `<`, `<=` → 숫자 타입의 대소 비교
- 동등 연산자(equality operator) `==`, `!=` → 모든 타입에 대한 동등 비교

### 수치 비교 연산자

수치 비교 연산자는 숫자 타입 또는 호환되는 타입에만 사용할 수 있으며 두 피연산자의 대소를 비교한다.

- `A > B` → A가 B보다 크면 `true` 작거나 같으면 `false`
- `A >= B` → A가 B보다 크거나 같으면 `true` 작으면 `false`
- `A < B` → A가 B보다 작으면 `true` 크거나 같으면 `false`
- `A <= B` → A가 B보다 작거나 같으면 `true` 크면 `false`

```java
int num1 = 10;
int num2 = 20;

System.out.println("num1 > num2 = " + (num1 > num2));   // num1 > num2 = false
System.out.println("num1 >= num2 = " + (num1 >= num2)); // num1 >= num2 = false
System.out.println("num1 < num2 = " + (num1 < num2));   // num1 < num2 = true
System.out.println("num1 <= num2 = " + (num1 <= num2)); // num1 <= num2 = true
```

### 동등 연산자

동등 연산자는 모든 타입(기본 타입 + 참조 타입)에 사용할 수 있으며 두 피연산자의 동등 여부를 비교한다. 두 피연산자는 서로 동등 비교가 가능한 타입이어야 한다.

- `A == B` → A, B가 같으면 `true` 다르면 `false`
- `A != B` → A, B가 다르면 `true` 같으면 `false`

```java
int value1 = 15;
int value2 = 30;

System.out.println("value1 == value2 = " + (value1 == value2)); // value1 == value2 = false
System.out.println("value1 != value2 = " + (value1 != value2)); // value1 != value2 = true

boolean isTrue = true;
boolean isFalse = false;

System.out.println("isTrue == isTrue = " + (isTrue == isTrue));     // isTrue == isTrue = true
System.out.println("isFalse == isFalse = " + (isFalse == isFalse)); // isFalse == isFalse = true
System.out.println("isTrue != isFalse = " + (isTrue != isFalse));   // isTrue != isTrue = false
```

<br>

## 조건/논리 연산자

조건/논리 연산자(conditional/logical operators)는 `boolean` 타입 피연산자 혹은 호환되는 타입에 사용할 수 있으며 복합적인 조건식을 만들기 위해 사용된다.

- `A && B` → 조건부 AND 연산자, A, B 모두 `true` 일 경우에만 `true` 이외에는 `false`
- `A || B` → 조건부 OR 연산자, A, B 둘 중 하나라도 `true` 인 경우 `true` 이외에는 `false`
- `!A` → 논리 부정 연산자, A의 논리를 반전시킴 `true` <-> `false`

```java
int age = 20;
int height = 170;
// &&, 조건부 AND
// 나이 20세 이상이면서 키 170이상인 경우
System.out.println("age >= 20 && height >= 170 = " + (age >= 20 && height >= 170)); // age >= 20 && height >= 170 = true

// ||, 조건부 OR
// 나이 30세 이상이거나 키 180이하인 경우
System.out.println("age >= 30 && height <= 180 = " + (age >= 30 && height <= 180)); // age >= 30 && height <= 180 = false

// !, 논리 부정
System.out.println("!true = " + !true);   // !true = false
System.out.println("!false = " + !false); // !false = true
```

> short-circuit evaluation
>
> 조건부 AND, OR 연산자는 필요한 경우에만 오른쪽 피연산자를 평가하는데 이를 short-circuit evaluation이라 한다. `&&` 는 왼쪽 피연산자가 `false` 라면 어떤 경우에도 `false`, `||` 는 왼쪽 피연산자가 `true` 라면 어떤 경우에도 `true` 다. 따라서 오른쪽 피연산자의 값에 관계없이 연산자의 반환값을 결정할 수 있는 경우 오른쪽 피연산자의 값을 평가하지 않는다.

<br>

## 비트 연산자

비트 연산자(bit operators)는 피연산자의 비트에 대해 처리되는 연산자로 정수 타입 혹은 `boolean` 타입에 사용할 수 있다.

- 비트 단위 연산자(bitwise operator) → `&`, `|`, `^`, `~`
- 시프트 연산자(shift operator) → `>>`, `<<`, `>>>`

### 비트 단위 연산자(integer)

비트 단위 연산자는 두 피연산자의 비트 패턴을 비교하거나 피연산자의 비트 패턴을 반전시킨다.

- `A & B` → A, B를 비트 단위로 비교하여 두 피연산자의 비트가 모두 1이면 1 아니면 0으로 처리함
- `A | B` → A, B를 비트 단위로 비교하여 두 피연산자의 비트 중 1이 있는 경우 1 아니면 0으로 처리함
- `A ^ B` → A, B를 비트 단위로 비교하여 두 피연산자의 비트가 서로 다른 경우 1 아니면 0으로 처리함
- `~A` → A의 비트 패턴을 반전시킴 0 <-> 1

```java
int num1 = 0b1111;
int num2 = 0b0001;

System.out.println("num1 & num2 = " + (num1 & num2)); // num1 & num2 = 1 (0b0001)
System.out.println("num1 | num2 = " + (num1 | num2)); // num1 | num2 = 15 (0b1111)
System.out.println("num1 ^ num2 = " + (num1 ^ num2)); // num1 ^ num2 = 14 (0b1110)
System.out.println("~num1 = " + ~num1);               // ~num1 = -16 (0b111111...0000)
```

### 비트 단위 연산자(boolean)

비트 단위 연산자 `&`, `|`, `^` 는 `boolean` 타입에도 사용할 수 있으며 조건 연산자와 유사하게 동작한다.

- `A & B` → A, B 모두 `true` 이면 `true` 아니면 `false`
- `A | B` → A, B 중 하나라도 `true` 이면 `true` 아니면 `false`
- `A ^ B` → A, B가 다르면 `true` 같으면 `false`

```java
System.out.println("true & true = " + (true & true));   // true & true = true
System.out.println("true | false = " + (true | false)); // true | false = true
System.out.println("true ^ false = " + (true ^ false)); // true ^ false = true
```

> `&&`, `||` vs `&`, `|`
>
> `boolean` 타입에 사용할 때 조건부 AND, OR 연산자와 비트 단위 연산자는 같은 피연산자에 대해서 같은 반환값을 내지만 동작에는 차이점이 있다. `&&`, `||` 는 short-circuit evaluation이 적용되어 오른쪽 피연산자를 평가하지 않는 경우도 있지만 `&`, `|` 는 어떤 경우에도 두 피연산자를 모두 평가한다.

### 시프트 연산자

시프트 연산자 피연산자의 비트 패턴을 이동시키는 연산자로 정수 타입 피연산자에 사용할 수 있고 이동 방향과 부호에 따라 3가지 연산자로 구분된다.

- `A >> B` → A의 비트 패턴을 B 만큼 오른쪽으로 이동, 왼쪽 빈자리는 A의 부호 비트로 채움, A / 2ᴮ와 같음
- `A << B` → A의 비트 패턴을 B 만큼 왼쪽으로 이동, 오른쪽 빈자리는 0으로 채움, A \* 2ᴮ와 같음
- `A >>> B` → A의 비트 패턴을 B 만큼 오른쪽으로 이동, 오른쪽 빈자리는 0으로 채움, A / 2ᴮ와 같지만 부호에 영향이 있음

```java
int num1 = 128;
int count = 3;
System.out.println("num1 >> count = " + (num1 >> count)); // num >> count = 16
System.out.println("num1 << count = " + (num1 << count)); // num << count = 1024

num1 = -128;
System.out.println("num1 >>> count = " + (num1 >>> count)); // num1 >>> count = 536870896, 부호 변경!
```

<br>

## 복합 할당 연산자

복합 할당 연산자(compound assignment operators)는 일부 연산자와 할당 연산자를 결합한 연산자로 연산의 처리와 해당 처리 결과를 다시 변수에 할당하는 과정을 하나의 연산자로 묶은것을 말한다.

- `A += B` → `A = A + B`
- `A -= B` → `A = A - B`
- `A *= B` → `A = A * B`
- `A /= B` → `A = A / B`
- `A %= B` → `A = A % B`
- `A &= B` → `A = A & B`
- `A |= B` → `A = A | B`
- `A ^= B` → `A = A ^ B`
- `A >>= B` → `A = A >> B`
- `A <<= B` → `A = A << B`
- `A >>>= B` → `A = A >>> B`

```java
int num1 = 5;
int num2 = 3;
num1 += num2; // num1 = num1 + num2
System.out.println(num1); // 8

num1 = 5;
num1 -= num2; // num1 = num1 - num2
System.out.println(num1); // 2

num1 = 5;
num1 *= num2; // num1 = num1 * num2
System.out.println(num1); // 15

num1 = 5;
num1 /= num2; // num1 = num1 / num2
System.out.println(num1); // 1

num1 = 5;
num1 %= num2; // num1 = num1 % num2
System.out.println(num1); // 2

num1 = 5;
num1 &= num2; // num1 = num1 & num2
System.out.println(num1); // 1

num1 = 5;
num1 |= num2; // num1 = num1 | num2
System.out.println(num1); // 7

num1 = 5;
num1 ^= num2; // num1 = num1 ^ num2
System.out.println(num1); // 6

num1 = 5;
num1 >>= num2; // num1 = num1 >> num2
System.out.println(num1); // 0

num1 = 5;
num1 <<= num2; // num1 = num1 << num2
System.out.println(num1); // 40

num1 = 5;
num1 >>>= num2; // num1 = num1 >>> num2
System.out.println(num1); // 0
```

<br>

## References

- [Using Operators in Your Programs - Dev.java](https://dev.java/learn/language-basics/using-operators/)
- [Java Language Specification se21 #ch15 - Oracle](https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html)
- [김영한의 자바 입문 - 코드로 시작하는 자바 첫걸음 - 김영한, Inflearn](https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%9E%90%EB%B0%94-%EC%9E%85%EB%AC%B8)
